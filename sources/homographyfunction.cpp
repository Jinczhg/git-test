#include "homographyfunction.h"

using namespace std;
using namespace cv;

int FindHomography(const CvMat* objectPoints, const CvMat* imagePoints,
	CvMat* __H, int method, double ransacReprojThreshold,
	CvMat* mask)
{
	const double confidence = 0.995;
	const int maxIters = 2000;
	const double defaultRANSACReprojThreshold = 3;
	bool result = false;
	Ptr<CvMat> m, M, tempMask;

	double H[9];
	CvMat matH = cvMat(3, 3, CV_64FC1, H);
	int count;

	CV_Assert(CV_IS_MAT(imagePoints) && CV_IS_MAT(objectPoints));

	count = MAX(imagePoints->cols, imagePoints->rows);
	CV_Assert(count >= 4);
	if (ransacReprojThreshold <= 0)
		ransacReprojThreshold = defaultRANSACReprojThreshold;

	m = cvCreateMat(1, count, CV_64FC2);
	cvConvertPointsHomogeneous(imagePoints, m);

	M = cvCreateMat(1, count, CV_64FC2);
	cvConvertPointsHomogeneous(objectPoints, M);

	if (mask)
	{
		CV_Assert(CV_IS_MASK_ARR(mask) && CV_IS_MAT_CONT(mask->type) &&
			(mask->rows == 1 || mask->cols == 1) &&
			mask->rows*mask->cols == count);
	}
	if (mask || count > 4)
		tempMask = cvCreateMat(1, count, CV_8U);
	if (!tempMask.empty())
		cvSet(tempMask, cvScalarAll(1.));

	CvHomographyEstimator estimator(4);
	if (count == 4)
		method = 0;
	if (method == CV_LMEDS)
		result = estimator.runLMeDS(M, m, &matH, tempMask, confidence, maxIters);
	else if (method == CV_RANSAC)
		result = estimator.runRANSAC(M, m, &matH, tempMask, ransacReprojThreshold, confidence, maxIters);
	else
		result = estimator.runKernel(M, m, &matH) > 0;

	if (result && count > 4)
	{
		icvCompressPoints((CvPoint2D64f*)M->data.ptr, tempMask->data.ptr, 1, count);
		count = icvCompressPoints((CvPoint2D64f*)m->data.ptr, tempMask->data.ptr, 1, count);
		M->cols = m->cols = count;
		if (method == CV_RANSAC)
			estimator.runKernel(M, m, &matH);
		estimator.refine(M, m, &matH, 10);
	}

	if (result)
		cvConvert(&matH, __H);

	if (mask && tempMask)
	{
		if (CV_ARE_SIZES_EQ(mask, tempMask))
			cvCopy(tempMask, mask);
		else
			cvTranspose(tempMask, mask);
	}

	return (int)result;
}

template<typename T> int icvCompressPoints(T* ptr, const uchar* mask, int mstep, int count)
{
	int i, j;
	for (i = j = 0; i < count; i++)
	if (mask[i*mstep])
	{
		if (i > j)
			ptr[j] = ptr[i];
		j++;
	}
	return j;
}


//class CvHomographyEstimator
CvHomographyEstimator::CvHomographyEstimator(int _modelPoints)
: CvModelEstimator2(_modelPoints, cvSize(3, 3), 1)
{
	assert(_modelPoints == 4 || _modelPoints == 5);
	checkPartialSubsets = false;
}

int CvHomographyEstimator::runKernel(const CvMat* m1, const CvMat* m2, CvMat* H)
{
	int i, count = m1->rows*m1->cols;
	const CvPoint2D64f* M = (const CvPoint2D64f*)m1->data.ptr;
	const CvPoint2D64f* m = (const CvPoint2D64f*)m2->data.ptr;

	double LtL[9][9], W[9][1], V[9][9];
	CvMat _LtL = cvMat(9, 9, CV_64F, LtL);
	CvMat matW = cvMat(9, 1, CV_64F, W);
	CvMat matV = cvMat(9, 9, CV_64F, V);
	CvMat _H0 = cvMat(3, 3, CV_64F, V[8]);
	CvMat _Htemp = cvMat(3, 3, CV_64F, V[7]);
	CvPoint2D64f cM = { 0, 0 }, cm = { 0, 0 }, sM = { 0, 0 }, sm = { 0, 0 };

	for (i = 0; i < count; i++)
	{
		cm.x += m[i].x; cm.y += m[i].y;
		cM.x += M[i].x; cM.y += M[i].y;
	}

	cm.x /= count; cm.y /= count;
	cM.x /= count; cM.y /= count;

	for (i = 0; i < count; i++)
	{
		sm.x += fabs(m[i].x - cm.x);
		sm.y += fabs(m[i].y - cm.y);
		sM.x += fabs(M[i].x - cM.x);
		sM.y += fabs(M[i].y - cM.y);
	}

	if (fabs(sm.x) < DBL_EPSILON || fabs(sm.y) < DBL_EPSILON ||
		fabs(sM.x) < DBL_EPSILON || fabs(sM.y) < DBL_EPSILON)
		return 0;
	sm.x = count / sm.x; sm.y = count / sm.y;
	sM.x = count / sM.x; sM.y = count / sM.y;

	double invHnorm[9] = { 1. / sm.x, 0, cm.x, 0, 1. / sm.y, cm.y, 0, 0, 1 };
	double Hnorm2[9] = { sM.x, 0, -cM.x*sM.x, 0, sM.y, -cM.y*sM.y, 0, 0, 1 };
	CvMat _invHnorm = cvMat(3, 3, CV_64FC1, invHnorm);
	CvMat _Hnorm2 = cvMat(3, 3, CV_64FC1, Hnorm2);

	cvZero(&_LtL);
	for (i = 0; i < count; i++)
	{
		double x = (m[i].x - cm.x)*sm.x, y = (m[i].y - cm.y)*sm.y;
		double X = (M[i].x - cM.x)*sM.x, Y = (M[i].y - cM.y)*sM.y;
		double Lx[] = { X, Y, 1, 0, 0, 0, -x*X, -x*Y, -x };
		double Ly[] = { 0, 0, 0, X, Y, 1, -y*X, -y*Y, -y };
		int j, k;
		for (j = 0; j < 9; j++)
		for (k = j; k < 9; k++)
			LtL[j][k] += Lx[j] * Lx[k] + Ly[j] * Ly[k];
	}
	cvCompleteSymm(&_LtL);

	//cvSVD( &_LtL, &matW, 0, &matV, CV_SVD_MODIFY_A + CV_SVD_V_T );
	cvEigenVV(&_LtL, &matV, &matW);
	cvMatMul(&_invHnorm, &_H0, &_Htemp);
	cvMatMul(&_Htemp, &_Hnorm2, &_H0);
	cvConvertScale(&_H0, H, 1. / _H0.data.db[8]);

	return 1;
}

void CvHomographyEstimator::computeReprojError(const CvMat* m1, const CvMat* m2,
	const CvMat* model, CvMat* _err)
{
	int i, count = m1->rows*m1->cols;
	const CvPoint2D64f* M = (const CvPoint2D64f*)m1->data.ptr;
	const CvPoint2D64f* m = (const CvPoint2D64f*)m2->data.ptr;
	const double* H = model->data.db;
	float* err = _err->data.fl;

	for (i = 0; i < count; i++)
	{
		double ww = 1. / (H[6] * M[i].x + H[7] * M[i].y + 1.);
		double dx = (H[0] * M[i].x + H[1] * M[i].y + H[2])*ww - m[i].x;
		double dy = (H[3] * M[i].x + H[4] * M[i].y + H[5])*ww - m[i].y;
		err[i] = (float)(dx*dx + dy*dy);
	}
}

bool CvHomographyEstimator::refine(const CvMat* m1, const CvMat* m2, CvMat* model, int maxIters)
{
	CvLevMarq solver(8, 0, cvTermCriteria(CV_TERMCRIT_ITER + CV_TERMCRIT_EPS, maxIters, DBL_EPSILON));
	int i, j, k, count = m1->rows*m1->cols;
	const CvPoint2D64f* M = (const CvPoint2D64f*)m1->data.ptr;
	const CvPoint2D64f* m = (const CvPoint2D64f*)m2->data.ptr;
	CvMat modelPart = cvMat(solver.param->rows, solver.param->cols, model->type, model->data.ptr);
	cvCopy(&modelPart, solver.param);

	for (;;)
	{
		const CvMat* _param = 0;
		CvMat *_JtJ = 0, *_JtErr = 0;
		double* _errNorm = 0;

		if (!solver.updateAlt(_param, _JtJ, _JtErr, _errNorm))
			break;

		for (i = 0; i < count; i++)
		{
			const double* h = _param->data.db;
			double Mx = M[i].x, My = M[i].y;
			double ww = h[6] * Mx + h[7] * My + 1.;
			ww = fabs(ww) > DBL_EPSILON ? 1. / ww : 0;
			double _xi = (h[0] * Mx + h[1] * My + h[2])*ww;
			double _yi = (h[3] * Mx + h[4] * My + h[5])*ww;
			double err[] = { _xi - m[i].x, _yi - m[i].y };
			if (_JtJ || _JtErr)
			{
				double J[][8] =
				{
					{ Mx*ww, My*ww, ww, 0, 0, 0, -Mx*ww*_xi, -My*ww*_xi },
					{ 0, 0, 0, Mx*ww, My*ww, ww, -Mx*ww*_yi, -My*ww*_yi }
				};

				for (j = 0; j < 8; j++)
				{
					for (k = j; k < 8; k++)
						_JtJ->data.db[j * 8 + k] += J[0][j] * J[0][k] + J[1][j] * J[1][k];
					_JtErr->data.db[j] += J[0][j] * err[0] + J[1][j] * err[1];
				}
			}
			if (_errNorm)
				*_errNorm += err[0] * err[0] + err[1] * err[1];
		}
	}

	cvCopy(solver.param, &modelPart);
	return true;
}

//class CvModelEstimator2
CvModelEstimator2::CvModelEstimator2(int _modelPoints, CvSize _modelSize, int _maxBasicSolutions)
{
	modelPoints = _modelPoints;
	modelSize = _modelSize;
	maxBasicSolutions = _maxBasicSolutions;
	checkPartialSubsets = true;
	rng = cvRNG(-1);
}

CvModelEstimator2::~CvModelEstimator2()
{
}

void CvModelEstimator2::setSeed(int64 seed)
{
	rng = cvRNG(seed);
}

int CvModelEstimator2::findInliers(const CvMat* m1, const CvMat* m2,
	const CvMat* model, CvMat* _err,
	CvMat* _mask, double threshold)
{
	int i, count = _err->rows*_err->cols, goodCount = 0;
	const float* err = _err->data.fl;
	uchar* mask = _mask->data.ptr;

	computeReprojError(m1, m2, model, _err);
	threshold *= threshold;
	for (i = 0; i < count; i++)
		goodCount += mask[i] = err[i] <= threshold;
	return goodCount;
}

bool CvModelEstimator2::runRANSAC(const CvMat* m1, const CvMat* m2, CvMat* model,
	CvMat* mask0, double reprojThreshold,
	double confidence, int maxIters)
{
	bool result = false;
	cv::Ptr<CvMat> mask = cvCloneMat(mask0);
	cv::Ptr<CvMat> models, err, tmask;
	cv::Ptr<CvMat> ms1, ms2;

	int iter, niters = maxIters;
	int count = m1->rows*m1->cols, maxGoodCount = 0;
	CV_Assert(CV_ARE_SIZES_EQ(m1, m2) && CV_ARE_SIZES_EQ(m1, mask));

	if (count < modelPoints)
		return false;

	models = cvCreateMat(modelSize.height*maxBasicSolutions, modelSize.width, CV_64FC1);
	err = cvCreateMat(1, count, CV_32FC1);
	tmask = cvCreateMat(1, count, CV_8UC1);

	if (count > modelPoints)
	{
		ms1 = cvCreateMat(1, modelPoints, m1->type);
		ms2 = cvCreateMat(1, modelPoints, m2->type);
	}
	else
	{
		niters = 1;
		ms1 = cvCloneMat(m1);
		ms2 = cvCloneMat(m2);
	}

	for (iter = 0; iter < niters; iter++)
	{
		int i, goodCount, nmodels;
		if (count > modelPoints)
		{
			bool found = getSubset(m1, m2, ms1, ms2, 300);
			if (!found)
			{
				if (iter == 0)
					return false;
				break;
			}
		}

		nmodels = runKernel(ms1, ms2, models);
		if (nmodels <= 0)
			continue;
		for (i = 0; i < nmodels; i++)
		{
			CvMat model_i;
			cvGetRows(models, &model_i, i*modelSize.height, (i + 1)*modelSize.height);
			goodCount = findInliers(m1, m2, &model_i, err, tmask, reprojThreshold);

			if (goodCount > MAX(maxGoodCount, modelPoints - 1))
			{
				std::swap(tmask, mask);
				cvCopy(&model_i, model);
				maxGoodCount = goodCount;
				niters = cvRANSACUpdateNumIters(confidence,
					(double)(count - goodCount) / count, modelPoints, niters);
			}
		}
	}

	if (maxGoodCount > 0)
	{
		if (mask != mask0)
			cvCopy(mask, mask0);
		result = true;
	}

	return result;
}

bool CvModelEstimator2::getSubset(const CvMat* m1, const CvMat* m2,
	CvMat* ms1, CvMat* ms2, int maxAttempts)
{
	cv::AutoBuffer<int> _idx(modelPoints);
	int* idx = _idx;
	int i = 0, j, k, idx_i, iters = 0;
	int type = CV_MAT_TYPE(m1->type), elemSize = CV_ELEM_SIZE(type);
	const int *m1ptr = m1->data.i, *m2ptr = m2->data.i;
	int *ms1ptr = ms1->data.i, *ms2ptr = ms2->data.i;
	int count = m1->cols*m1->rows;

	assert(CV_IS_MAT_CONT(m1->type & m2->type) && (elemSize % sizeof(int) == 0));
	elemSize /= sizeof(int);

	for (; iters < maxAttempts; iters++)
	{
		for (i = 0; i < modelPoints && iters < maxAttempts;)
		{
			idx[i] = idx_i = cvRandInt(&rng) % count;
			for (j = 0; j < i; j++)
			if (idx_i == idx[j])
				break;
			if (j < i)
				continue;
			for (k = 0; k < elemSize; k++)
			{
				ms1ptr[i*elemSize + k] = m1ptr[idx_i*elemSize + k];
				ms2ptr[i*elemSize + k] = m2ptr[idx_i*elemSize + k];
			}
			if (checkPartialSubsets && (!checkSubset(ms1, i + 1) || !checkSubset(ms2, i + 1)))
			{
				iters++;
				continue;
			}
			i++;
		}
		if (!checkPartialSubsets && i == modelPoints &&
			(!checkSubset(ms1, i) || !checkSubset(ms2, i)))
			continue;
		break;
	}

	return i == modelPoints && iters < maxAttempts;
}

bool CvModelEstimator2::checkSubset(const CvMat* m, int count)
{
	if (count <= 2)
		return true;

	int j, k, i, i0, i1;
	CvPoint2D64f* ptr = (CvPoint2D64f*)m->data.ptr;

	assert(CV_MAT_TYPE(m->type) == CV_64FC2);

	if (checkPartialSubsets)
		i0 = i1 = count - 1;
	else
		i0 = 0, i1 = count - 1;

	for (i = i0; i <= i1; i++)
	{
		// check that the i-th selected point does not belong
		// to a line connecting some previously selected points
		for (j = 0; j < i; j++)
		{
			double dx1 = ptr[j].x - ptr[i].x;
			double dy1 = ptr[j].y - ptr[i].y;
			for (k = 0; k < j; k++)
			{
				double dx2 = ptr[k].x - ptr[i].x;
				double dy2 = ptr[k].y - ptr[i].y;
				if (fabs(dx2*dy1 - dy2*dx1) <= FLT_EPSILON*(fabs(dx1) + fabs(dy1) + fabs(dx2) + fabs(dy2)))
					break;
			}
			if (k < j)
				break;
		}
		if (j < i)
			break;
	}

	return i > i1;
}


